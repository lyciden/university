# Task description
    The task is to implement the CPersonalAgenda class that will implement the employee database.

    To facilitate the work of the HR department we have implemented an employee database. We remember the first name, last name, email and salary for the employees we are tracking. During the course of employee's record these details may change, we want to search the details and we want to keep track of the salary.

    An employee is identified by his first and last name or by his email. Company procedures ensure that the email is unique across the entire database. Further, first and last names may be repeated, but the pair (first name, last name) is again unique in the database. Thus, there may be many people in the database with the last name Svoboda, many people may have the first name Peter, but there can only be one Svoboda Peter employee in the database at any given time. When matching first names, last names and emails, we are case sensitive.

    The public interface is shown below. It contains the following:

    Constructor without parameters. This constructor initializes an instance of the class so that the resulting instance is empty for now (contains no records).
    Destructor. Releases the resources that the instance has allocated.
    The add(name, surname, email, salary) method adds another record to the existing database. The name and surname parameters represent first and last names, the email parameter represents the email address, and the salary parameter represents the salary. The method returns true if the record has been added, or false if it has not been added (because a record with the same first and last name or a record with the same email address already existed in the database).
    The del (name, surname) / del (email) methods remove the record from the database. The parameter is a unique identification by first and last name (first option) or by email (second option). If the record was actually removed, the method returns true. If the record was not removed (because there was no employee with this identification), the method returns false.
    The changeName(email, newName, newSurname) method changes the employee's first and last name. The employee is identified by the email email, the employee's name is changed to newName/newSurname. The method returns true for success, false for error (there is no employee with that email, the newly assigned first/last name is not unique).
    The changeEmail(name, surname, newEmail) method changes the employee's email. The employee is identified by first name/surname, the employee's email is changed to newEmail. The method returns true for success, false for error (there is no employee with that name and surname, the newly assigned email is not unique).
    The setSalary (name, surname, salary) / setSalary (email, salary) methods change the salary amount for the specified employee. There are two options - the employee is identified either by their first and last name or by their email address. If the method succeeds, it returns true, for failure it returns false (non-existent employee).
    The getSalary (name, surname) / getSalary (email) methods find out the salary of the specified employee. There are two options - the employee is identified either by his name and surname or by his email address. If the method succeeds, it returns the employee's salary amount, for failure (non-existent employee) it returns 0.
    The getRank (name, surname, rankMin, rankMax) / getRank (email, rankMin, rankMax) methods determine how well the employee is paid relative to others. The result is the position of the specified employee's salary on an imaginary ranking of salaries from worst (lowest) to best (highest). The parameter is the identification of the employee (either by first and last name or email address, depending on the variant), the parameters rankMin/rankMax are output, into which the function writes the position of the salary of the searched employee in the ranking. Since multiple employees can receive the same salary, the output is a pair of values - the min-max interval. For example, if the searched employee receives a salary of 20000, 37 employees receive a lower salary, and 21 other employees receive the same salary (i.e., a total of 22 employees receive a salary of 20000), then the output is rankMin=37 and rankMax=37+22-1=58. The return value of the function is true for success (specified employee found, output parameters filled) or false (specified employee not found, output parameters left unchanged).
    The getFirst ( outName, outSurname ) method is used to browse databases. We want to browse employees alphabetically (sorted in ascending order by last name, in case of same last name by first name). The method returns the first employee in the sorted list, and writes the employee's first and last name to the output parameters outName/outSurname. The return value is true for success (the database was not empty) or false (empty database, output parameters left unchanged).
    The getNext ( name, surname, outName, outSurname ) method is used to browse employees similarly to the getFirst method. This method returns the next employee that follows the name/surname employee in the sorted list of employees (see getFirst). It writes the name of the next employee to the specified output parameters outName/outSurname. The return value is true for success (employee name/surname is found and is not the last in the sorted list) or false for failure (employee name/surname is not found or is the last in the list). In case of failure, the method will not change the output parameters outName/outSurname.
    Commit a file that contains the implemented CPersonalAgenda class. The class must conform to the public interface as shown in the sample - if your submitted solution does not contain the described interface, a compilation error will occur. However, you can add additional methods (public or private) and member variables to the class. You can also add additional support functions or classes to the submission file. The commit file must contain the class declaration (interface description) as well as method, constructor, and destructor definitions. It does not matter whether the methods are implemented inline or separately. The commit file must not contain header file insertion and the main function (the main function and header file insertion may remain, but only wrapped by conditional compilation directives). Use the attached source file as the basis for the implementation.

    The class interface contains a number of methods in two variants that differ only in the way the employee is identified. It is advisable to spend non-zero time designing the class so that you do not copy all the executable code twice (e.g., implement private methods that you will call from multiple public methods).

    The class is tested in a constrained environment where the available memory is limited (enough to store the list) and is limited by the runtime. The implemented class does not have to deal with a copy constructor or overloading the = operator. ProgTest does not test this functionality in this task.

    The implementation of the class must be efficient in terms of time and memory requirements. A simple linear solution is not sufficient (it requires over 5 minutes of time for the test data). Assume that inserting and deleting an employee are orders of magnitude less frequent than other operations, so linear complexity is acceptable here. The getSalary and setSalary calls are frequent, their time complexity must be better than linear (e.g. logarithmic or amortized constant). Furthermore, getFirst/getNext methods should also be efficient, their complexity should also be better than linear.

    In the mandatory tests, the getRank method is called infrequently, so it may not be very efficient (linear or n log n complexity is sufficient for success in the mandatory tests; for the bonus test, better than linear complexity is needed. If you don't want to devise an efficient algorithm for the bonus test, focus rather on making the setSalary calls efficient even at the cost of the less efficient getRank method.

    There are several ways to solve the bonus test. When designing a solution, you can use the knowledge that the wage value you specify is at most 1000000. Additionally, knowing that wage values are often repeated can help.

    To store the values, allocate the fields dynamically or use STL. Note that if you allocate the field on your own, choose an initial size of small (e.g. 1000 elements) and increase/decrease the size as needed. It is not advisable to allocate a new array larger by only one value when the array is full, such a procedure has a huge overhead on copying content. It is reasonable to expand the array with a step of the order of thousands of elements, or a geometric series with a quotient of ~1.5 to 2.

    If you use STL, you don't have to worry about allocation problems. Beware - only part of the STL is available to you (see the header files in the attached sample). So for example the containers map / unordered_map / set / unordered_set / ... are not available.

    The attached source code contains the basic tests. These tests are far from covering all situations, you will need to extend them to debug the class. Please note that we consider the tests contained in the submitted source code to be an integral part of your solution. If you leave extraneous tests in your submitted solution, the work may be evaluated as copied.